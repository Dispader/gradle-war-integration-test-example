apply plugin: 'war'
apply plugin: 'jetty'
apply plugin: 'groovy'
apply plugin: 'eclipse'

configurations {
    integrationTestCompile.extendsFrom compile
    integrationTestRuntime.extendsFrom runtime
}

sourceSets {
    integrationTest {
        java {
            compileClasspath += main.output
            runtimeClasspath += main.output
        }
        resources.srcDir file('src/integrationTest/resources')
    }
}

task integrationTest(type:Test) {
    group = 'Verification'
    description = 'Deploys the application to Jetty, and runs the integration tests.'
    dependsOn 'assemble', 'integrationTestClasses'
    testClassesDir = sourceSets.integrationTest.output.classesDir
    classpath = sourceSets.integrationTest.runtimeClasspath
    outputs.upToDateWhen { false }
}

tasks.withType(Test) {
    reports.html.destination = file("${reporting.baseDir}/${name}")
    testLogging.exceptionFormat = 'full'
}

// While we could inherit them, or mix them with `testCompile` resources, we choose to separate them.
dependencies {
//    add your dependencies to the `integrationTestCompile` resources set to your main build, e.g.:
//    integrationTestCompile 'org.spockframework:spock-core:1.0-groovy-2.3'
}

import org.gradle.api.plugins.jetty.internal.Monitor // WORKAROUND: GRADLE-2263
// WORKAROUND: GRADLE-2263
// @see http://issues.gradle.org/browse/GRADLE-2263
[jettyRun, jettyRunWar, jettyStop]*.stopPort = 8081
[jettyRun, jettyRunWar, jettyStop]*.stopKey = 'stopKey'
[jettyRun, jettyRunWar]*.doLast {
     if (getStopPort() != null && getStopPort() > 0 && getStopKey() != null) {
         Monitor monitor = new Monitor(getStopPort(), getStopKey(), server.getProxiedObject());
         monitor.start();
     }
}
tasks.jettyRun.description = 'Assembles the webapp and deploys it to Jetty.'
tasks.jettyRun.dependsOn jettyStop

integrationTest.doFirst {
    tasks.jettyRun.daemon = true
    tasks.jettyRun.execute()
}
integrationTest.finalizedBy {
    tasks.jettyStop.execute()
}

jettyRun {
    description = 'Assembles the webapp, using the integraiton test configuration, and deploys it to Jetty.'
    classpath = sourceSets.integrationTest.runtimeClasspath
}

// WORKAROUND: GRADLE-6986
// @see https://discuss.gradle.org/t/eclipse-generated-files-should-be-put-in-the-same-place-as-the-gradle-generated-files/6986
Map pathMappings = [:];
SourceSetContainer sourceSets = project.sourceSets;
sourceSets.each { SourceSet sourceSet ->
    String relativeJavaOutputDirectory = project.relativePath(sourceSet.output.classesDir);
    String relativeResourceOutputDirectory = project.relativePath(sourceSet.output.resourcesDir);
    sourceSet.java.getSrcDirTrees().each { DirectoryTree sourceDirectory ->
        String relativeSrcPath = project.relativePath(sourceDirectory.dir.absolutePath);
        pathMappings[relativeSrcPath] = relativeJavaOutputDirectory;
    }
    sourceSet.resources.getSrcDirTrees().each { DirectoryTree resourceDirectory ->
        String relativeResourcePath = project.relativePath(resourceDirectory.dir.absolutePath);
        pathMappings[relativeResourcePath] = relativeResourceOutputDirectory;
    }
}
project.eclipse.classpath.file {
    whenMerged { classpath ->
        classpath.entries.findAll { entry ->
            return entry.kind == 'src';
        }.each { entry ->
            if(pathMappings.containsKey(entry.path)) {
                entry.output = pathMappings[entry.path];
            }
        }
    }
}
tasks.eclipse.dependsOn cleanEclipse

import org.gradle.plugins.ide.eclipse.model.EclipseModel
def eclipseModel = project.extensions.findByType EclipseModel
if (eclipseModel) {
    def eclipseClasspath = eclipseModel.classpath;
    eclipseClasspath.plusConfigurations.add project.configurations.integrationTestCompile
    eclipseClasspath.plusConfigurations.add project.configurations.integrationTestRuntime
}
